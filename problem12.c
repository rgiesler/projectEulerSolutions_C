#include <stdio.h>
#include <math.h>
#include <stdlib.h>

/*	The sequence of triangle numbers is generated by adding the natural numbers.
	So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The 
	first ten terms would be:

		1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

	Let us list the factors of the first seven triangle numbers:

		 1: 1
		 3: 1,3
		 6: 1,2,3,6
		10: 1,2,5,10
		15: 1,3,5,15
		21: 1,3,7,21
		28: 1,2,4,7,14,28

	We can see that 28 is the first triangle number to have over five divisors.

	What is the value of the first triangle number to have over five hundred 
	divisors?
*/

int numDivisors(int n, int *primes, int numPrimes);
int sieve(int lim, int **primes);

int main(int argc, char *argv[])
{
	int number = 0, i = 1;	//	number is triangle number, i is current term
	int sizeOfPrimes = 1000, sizeOfPrimesSqr = 1000000;
	int *primes;
	int numPrimes = sieve(sizeOfPrimes, &primes);

	while(numDivisors(number, primes, numPrimes) < 500) {
		if(sizeOfPrimesSqr < number) {	// Update if it becomes too small
			sizeOfPrimes *= 5;
			sizeOfPrimesSqr = sizeOfPrimes*sizeOfPrimes;
			numPrimes = sieve(sizeOfPrimes, &primes);
		}
		number += i++;					// Increment number
	}

	printf("Triangle number: %d\n", number);

	free(primes);

	return 0;
}

int numDivisors(int n, int *primes, int numPrimes)
{
	int num = 1, exponent, i;
	int lim = (int)sqrt((double)n);

	for(i = 0; i < numPrimes; i++) {

		if(primes[i] > lim) {	// check for ending limit
			return num*2;
		}
		
		exponent = 1;					// exponent for prime
		while(n%primes[i] == 0) {
			n /= primes[i];
			exponent++;
		}
		num *= exponent;

		if(n == 1) {				// found all prime factors
			return num;
		}
	}

	return num;
}

int sieve(int lim, int **primes)
{
	const int limSqrt = (int)sqrt((double)lim);
	int i, j, count = 0;
	char *nums = (char*)calloc(lim,sizeof(char));

	nums[0] = 1;	// 0 and 1 aren't primes
	nums[1] = 1;
	free(*primes);	// Deallocate old primes
	for(i = 2; i <= limSqrt; i++) 
		if(!nums[i]) 
			for(j = i*2; j < lim; j+=i) 
				nums[j] = 1;
	// Count number of primes
	for(i = 0; i < lim; i++)
		if(!nums[i])
			count++;
	// Allocate memory
	*primes = (int*)malloc(count*sizeof(int));
	// Assign primes
	j = 0;
	for(i = 0; i < lim; i++)
		if(!nums[i]) 
			(*primes)[j++] = i;

	free(nums);
	return count;
}

/*	Sieve is from problem 10, and explination can be found there. It is modified
	to return an array of primes. We will use prime factorization like in 
	Problem 3.

	We use combinatorics to find the number of divisors. If we have a prime
	pn with an exponent an, that prime can be chosen (0, 1, ..., an) times,
	so we have (an + 1) choices. This gives us the number of divisors as:

	D = (a1 + 1) * (a2 + 1) * (a3 + 1) * ... * (an + 1)
*/